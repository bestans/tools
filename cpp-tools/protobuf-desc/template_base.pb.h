// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: template_base.proto

#ifndef PROTOBUF_INCLUDED_template_5fbase_2eproto
#define PROTOBUF_INCLUDED_template_5fbase_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_template_5fbase_2eproto 

namespace protobuf_template_5fbase_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_template_5fbase_2eproto
namespace bestan {
namespace common {
namespace config {
class excel_cell_data;
class excel_cell_dataDefaultTypeInternal;
extern excel_cell_dataDefaultTypeInternal _excel_cell_data_default_instance_;
class excel_line_data;
class excel_line_dataDefaultTypeInternal;
extern excel_line_dataDefaultTypeInternal _excel_line_data_default_instance_;
class excel_path_cell;
class excel_path_cellDefaultTypeInternal;
extern excel_path_cellDefaultTypeInternal _excel_path_cell_default_instance_;
class excel_path_full;
class excel_path_fullDefaultTypeInternal;
extern excel_path_fullDefaultTypeInternal _excel_path_full_default_instance_;
class excel_proto;
class excel_protoDefaultTypeInternal;
extern excel_protoDefaultTypeInternal _excel_proto_default_instance_;
class excel_proto_AllProtoEntry_DoNotUse;
class excel_proto_AllProtoEntry_DoNotUseDefaultTypeInternal;
extern excel_proto_AllProtoEntry_DoNotUseDefaultTypeInternal _excel_proto_AllProtoEntry_DoNotUse_default_instance_;
class excel_section;
class excel_sectionDefaultTypeInternal;
extern excel_sectionDefaultTypeInternal _excel_section_default_instance_;
class excel_table;
class excel_tableDefaultTypeInternal;
extern excel_tableDefaultTypeInternal _excel_table_default_instance_;
class excel_table_TableEntry_DoNotUse;
class excel_table_TableEntry_DoNotUseDefaultTypeInternal;
extern excel_table_TableEntry_DoNotUseDefaultTypeInternal _excel_table_TableEntry_DoNotUse_default_instance_;
class test_python;
class test_pythonDefaultTypeInternal;
extern test_pythonDefaultTypeInternal _test_python_default_instance_;
class test_python_all;
class test_python_allDefaultTypeInternal;
extern test_python_allDefaultTypeInternal _test_python_all_default_instance_;
class test_python_all_ConfigsEntry_DoNotUse;
class test_python_all_ConfigsEntry_DoNotUseDefaultTypeInternal;
extern test_python_all_ConfigsEntry_DoNotUseDefaultTypeInternal _test_python_all_ConfigsEntry_DoNotUse_default_instance_;
class test_python_skill_data;
class test_python_skill_dataDefaultTypeInternal;
extern test_python_skill_dataDefaultTypeInternal _test_python_skill_data_default_instance_;
}  // namespace config
}  // namespace common
}  // namespace bestan
namespace google {
namespace protobuf {
template<> ::bestan::common::config::excel_cell_data* Arena::CreateMaybeMessage<::bestan::common::config::excel_cell_data>(Arena*);
template<> ::bestan::common::config::excel_line_data* Arena::CreateMaybeMessage<::bestan::common::config::excel_line_data>(Arena*);
template<> ::bestan::common::config::excel_path_cell* Arena::CreateMaybeMessage<::bestan::common::config::excel_path_cell>(Arena*);
template<> ::bestan::common::config::excel_path_full* Arena::CreateMaybeMessage<::bestan::common::config::excel_path_full>(Arena*);
template<> ::bestan::common::config::excel_proto* Arena::CreateMaybeMessage<::bestan::common::config::excel_proto>(Arena*);
template<> ::bestan::common::config::excel_proto_AllProtoEntry_DoNotUse* Arena::CreateMaybeMessage<::bestan::common::config::excel_proto_AllProtoEntry_DoNotUse>(Arena*);
template<> ::bestan::common::config::excel_section* Arena::CreateMaybeMessage<::bestan::common::config::excel_section>(Arena*);
template<> ::bestan::common::config::excel_table* Arena::CreateMaybeMessage<::bestan::common::config::excel_table>(Arena*);
template<> ::bestan::common::config::excel_table_TableEntry_DoNotUse* Arena::CreateMaybeMessage<::bestan::common::config::excel_table_TableEntry_DoNotUse>(Arena*);
template<> ::bestan::common::config::test_python* Arena::CreateMaybeMessage<::bestan::common::config::test_python>(Arena*);
template<> ::bestan::common::config::test_python_all* Arena::CreateMaybeMessage<::bestan::common::config::test_python_all>(Arena*);
template<> ::bestan::common::config::test_python_all_ConfigsEntry_DoNotUse* Arena::CreateMaybeMessage<::bestan::common::config::test_python_all_ConfigsEntry_DoNotUse>(Arena*);
template<> ::bestan::common::config::test_python_skill_data* Arena::CreateMaybeMessage<::bestan::common::config::test_python_skill_data>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace bestan {
namespace common {
namespace config {

enum excel_section_DATA_TYPE {
  excel_section_DATA_TYPE_INT32 = 0,
  excel_section_DATA_TYPE_INT64 = 1,
  excel_section_DATA_TYPE_STRING = 2,
  excel_section_DATA_TYPE_FLOAT = 3,
  excel_section_DATA_TYPE_DOUBLE = 4,
  excel_section_DATA_TYPE_excel_section_DATA_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  excel_section_DATA_TYPE_excel_section_DATA_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool excel_section_DATA_TYPE_IsValid(int value);
const excel_section_DATA_TYPE excel_section_DATA_TYPE_DATA_TYPE_MIN = excel_section_DATA_TYPE_INT32;
const excel_section_DATA_TYPE excel_section_DATA_TYPE_DATA_TYPE_MAX = excel_section_DATA_TYPE_DOUBLE;
const int excel_section_DATA_TYPE_DATA_TYPE_ARRAYSIZE = excel_section_DATA_TYPE_DATA_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* excel_section_DATA_TYPE_descriptor();
inline const ::std::string& excel_section_DATA_TYPE_Name(excel_section_DATA_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    excel_section_DATA_TYPE_descriptor(), value);
}
inline bool excel_section_DATA_TYPE_Parse(
    const ::std::string& name, excel_section_DATA_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<excel_section_DATA_TYPE>(
    excel_section_DATA_TYPE_descriptor(), name, value);
}
enum excel_cell_data_DATA_TYPE {
  excel_cell_data_DATA_TYPE_INT32 = 0,
  excel_cell_data_DATA_TYPE_INT64 = 1,
  excel_cell_data_DATA_TYPE_STRING = 2,
  excel_cell_data_DATA_TYPE_FLOAT = 3,
  excel_cell_data_DATA_TYPE_DOUBLE = 4,
  excel_cell_data_DATA_TYPE_excel_cell_data_DATA_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  excel_cell_data_DATA_TYPE_excel_cell_data_DATA_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool excel_cell_data_DATA_TYPE_IsValid(int value);
const excel_cell_data_DATA_TYPE excel_cell_data_DATA_TYPE_DATA_TYPE_MIN = excel_cell_data_DATA_TYPE_INT32;
const excel_cell_data_DATA_TYPE excel_cell_data_DATA_TYPE_DATA_TYPE_MAX = excel_cell_data_DATA_TYPE_DOUBLE;
const int excel_cell_data_DATA_TYPE_DATA_TYPE_ARRAYSIZE = excel_cell_data_DATA_TYPE_DATA_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* excel_cell_data_DATA_TYPE_descriptor();
inline const ::std::string& excel_cell_data_DATA_TYPE_Name(excel_cell_data_DATA_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    excel_cell_data_DATA_TYPE_descriptor(), value);
}
inline bool excel_cell_data_DATA_TYPE_Parse(
    const ::std::string& name, excel_cell_data_DATA_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<excel_cell_data_DATA_TYPE>(
    excel_cell_data_DATA_TYPE_descriptor(), name, value);
}
// ===================================================================

class excel_section : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bestan.common.config.excel_section) */ {
 public:
  excel_section();
  virtual ~excel_section();

  excel_section(const excel_section& from);

  inline excel_section& operator=(const excel_section& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  excel_section(excel_section&& from) noexcept
    : excel_section() {
    *this = ::std::move(from);
  }

  inline excel_section& operator=(excel_section&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const excel_section& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const excel_section* internal_default_instance() {
    return reinterpret_cast<const excel_section*>(
               &_excel_section_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(excel_section* other);
  friend void swap(excel_section& a, excel_section& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline excel_section* New() const final {
    return CreateMaybeMessage<excel_section>(NULL);
  }

  excel_section* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<excel_section>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const excel_section& from);
  void MergeFrom(const excel_section& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(excel_section* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef excel_section_DATA_TYPE DATA_TYPE;
  static const DATA_TYPE INT32 =
    excel_section_DATA_TYPE_INT32;
  static const DATA_TYPE INT64 =
    excel_section_DATA_TYPE_INT64;
  static const DATA_TYPE STRING =
    excel_section_DATA_TYPE_STRING;
  static const DATA_TYPE FLOAT =
    excel_section_DATA_TYPE_FLOAT;
  static const DATA_TYPE DOUBLE =
    excel_section_DATA_TYPE_DOUBLE;
  static inline bool DATA_TYPE_IsValid(int value) {
    return excel_section_DATA_TYPE_IsValid(value);
  }
  static const DATA_TYPE DATA_TYPE_MIN =
    excel_section_DATA_TYPE_DATA_TYPE_MIN;
  static const DATA_TYPE DATA_TYPE_MAX =
    excel_section_DATA_TYPE_DATA_TYPE_MAX;
  static const int DATA_TYPE_ARRAYSIZE =
    excel_section_DATA_TYPE_DATA_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DATA_TYPE_descriptor() {
    return excel_section_DATA_TYPE_descriptor();
  }
  static inline const ::std::string& DATA_TYPE_Name(DATA_TYPE value) {
    return excel_section_DATA_TYPE_Name(value);
  }
  static inline bool DATA_TYPE_Parse(const ::std::string& name,
      DATA_TYPE* value) {
    return excel_section_DATA_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes section = 1;
  void clear_section();
  static const int kSectionFieldNumber = 1;
  const ::std::string& section() const;
  void set_section(const ::std::string& value);
  #if LANG_CXX11
  void set_section(::std::string&& value);
  #endif
  void set_section(const char* value);
  void set_section(const void* value, size_t size);
  ::std::string* mutable_section();
  ::std::string* release_section();
  void set_allocated_section(::std::string* section);

  // int32 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // .bestan.common.config.excel_section.DATA_TYPE data_type = 3;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 3;
  ::bestan::common::config::excel_section_DATA_TYPE data_type() const;
  void set_data_type(::bestan::common::config::excel_section_DATA_TYPE value);

  // @@protoc_insertion_point(class_scope:bestan.common.config.excel_section)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr section_;
  ::google::protobuf::int32 index_;
  int data_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_template_5fbase_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class excel_path_cell : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bestan.common.config.excel_path_cell) */ {
 public:
  excel_path_cell();
  virtual ~excel_path_cell();

  excel_path_cell(const excel_path_cell& from);

  inline excel_path_cell& operator=(const excel_path_cell& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  excel_path_cell(excel_path_cell&& from) noexcept
    : excel_path_cell() {
    *this = ::std::move(from);
  }

  inline excel_path_cell& operator=(excel_path_cell&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const excel_path_cell& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const excel_path_cell* internal_default_instance() {
    return reinterpret_cast<const excel_path_cell*>(
               &_excel_path_cell_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(excel_path_cell* other);
  friend void swap(excel_path_cell& a, excel_path_cell& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline excel_path_cell* New() const final {
    return CreateMaybeMessage<excel_path_cell>(NULL);
  }

  excel_path_cell* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<excel_path_cell>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const excel_path_cell& from);
  void MergeFrom(const excel_path_cell& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(excel_path_cell* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bestan.common.config.excel_section cell_path = 1;
  int cell_path_size() const;
  void clear_cell_path();
  static const int kCellPathFieldNumber = 1;
  ::bestan::common::config::excel_section* mutable_cell_path(int index);
  ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_section >*
      mutable_cell_path();
  const ::bestan::common::config::excel_section& cell_path(int index) const;
  ::bestan::common::config::excel_section* add_cell_path();
  const ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_section >&
      cell_path() const;

  // @@protoc_insertion_point(class_scope:bestan.common.config.excel_path_cell)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_section > cell_path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_template_5fbase_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class excel_path_full : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bestan.common.config.excel_path_full) */ {
 public:
  excel_path_full();
  virtual ~excel_path_full();

  excel_path_full(const excel_path_full& from);

  inline excel_path_full& operator=(const excel_path_full& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  excel_path_full(excel_path_full&& from) noexcept
    : excel_path_full() {
    *this = ::std::move(from);
  }

  inline excel_path_full& operator=(excel_path_full&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const excel_path_full& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const excel_path_full* internal_default_instance() {
    return reinterpret_cast<const excel_path_full*>(
               &_excel_path_full_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(excel_path_full* other);
  friend void swap(excel_path_full& a, excel_path_full& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline excel_path_full* New() const final {
    return CreateMaybeMessage<excel_path_full>(NULL);
  }

  excel_path_full* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<excel_path_full>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const excel_path_full& from);
  void MergeFrom(const excel_path_full& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(excel_path_full* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bestan.common.config.excel_path_cell paths = 1;
  int paths_size() const;
  void clear_paths();
  static const int kPathsFieldNumber = 1;
  ::bestan::common::config::excel_path_cell* mutable_paths(int index);
  ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_path_cell >*
      mutable_paths();
  const ::bestan::common::config::excel_path_cell& paths(int index) const;
  ::bestan::common::config::excel_path_cell* add_paths();
  const ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_path_cell >&
      paths() const;

  // @@protoc_insertion_point(class_scope:bestan.common.config.excel_path_full)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_path_cell > paths_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_template_5fbase_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class excel_cell_data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bestan.common.config.excel_cell_data) */ {
 public:
  excel_cell_data();
  virtual ~excel_cell_data();

  excel_cell_data(const excel_cell_data& from);

  inline excel_cell_data& operator=(const excel_cell_data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  excel_cell_data(excel_cell_data&& from) noexcept
    : excel_cell_data() {
    *this = ::std::move(from);
  }

  inline excel_cell_data& operator=(excel_cell_data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const excel_cell_data& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const excel_cell_data* internal_default_instance() {
    return reinterpret_cast<const excel_cell_data*>(
               &_excel_cell_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(excel_cell_data* other);
  friend void swap(excel_cell_data& a, excel_cell_data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline excel_cell_data* New() const final {
    return CreateMaybeMessage<excel_cell_data>(NULL);
  }

  excel_cell_data* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<excel_cell_data>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const excel_cell_data& from);
  void MergeFrom(const excel_cell_data& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(excel_cell_data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef excel_cell_data_DATA_TYPE DATA_TYPE;
  static const DATA_TYPE INT32 =
    excel_cell_data_DATA_TYPE_INT32;
  static const DATA_TYPE INT64 =
    excel_cell_data_DATA_TYPE_INT64;
  static const DATA_TYPE STRING =
    excel_cell_data_DATA_TYPE_STRING;
  static const DATA_TYPE FLOAT =
    excel_cell_data_DATA_TYPE_FLOAT;
  static const DATA_TYPE DOUBLE =
    excel_cell_data_DATA_TYPE_DOUBLE;
  static inline bool DATA_TYPE_IsValid(int value) {
    return excel_cell_data_DATA_TYPE_IsValid(value);
  }
  static const DATA_TYPE DATA_TYPE_MIN =
    excel_cell_data_DATA_TYPE_DATA_TYPE_MIN;
  static const DATA_TYPE DATA_TYPE_MAX =
    excel_cell_data_DATA_TYPE_DATA_TYPE_MAX;
  static const int DATA_TYPE_ARRAYSIZE =
    excel_cell_data_DATA_TYPE_DATA_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DATA_TYPE_descriptor() {
    return excel_cell_data_DATA_TYPE_descriptor();
  }
  static inline const ::std::string& DATA_TYPE_Name(DATA_TYPE value) {
    return excel_cell_data_DATA_TYPE_Name(value);
  }
  static inline bool DATA_TYPE_Parse(const ::std::string& name,
      DATA_TYPE* value) {
    return excel_cell_data_DATA_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes bytes_value = 4;
  void clear_bytes_value();
  static const int kBytesValueFieldNumber = 4;
  const ::std::string& bytes_value() const;
  void set_bytes_value(const ::std::string& value);
  #if LANG_CXX11
  void set_bytes_value(::std::string&& value);
  #endif
  void set_bytes_value(const char* value);
  void set_bytes_value(const void* value, size_t size);
  ::std::string* mutable_bytes_value();
  ::std::string* release_bytes_value();
  void set_allocated_bytes_value(::std::string* bytes_value);

  // .bestan.common.config.excel_cell_data.DATA_TYPE data_type = 1;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 1;
  ::bestan::common::config::excel_cell_data_DATA_TYPE data_type() const;
  void set_data_type(::bestan::common::config::excel_cell_data_DATA_TYPE value);

  // int32 int32_value = 2;
  void clear_int32_value();
  static const int kInt32ValueFieldNumber = 2;
  ::google::protobuf::int32 int32_value() const;
  void set_int32_value(::google::protobuf::int32 value);

  // int64 int64_value = 3;
  void clear_int64_value();
  static const int kInt64ValueFieldNumber = 3;
  ::google::protobuf::int64 int64_value() const;
  void set_int64_value(::google::protobuf::int64 value);

  // double double_value = 6;
  void clear_double_value();
  static const int kDoubleValueFieldNumber = 6;
  double double_value() const;
  void set_double_value(double value);

  // float float_value = 5;
  void clear_float_value();
  static const int kFloatValueFieldNumber = 5;
  float float_value() const;
  void set_float_value(float value);

  // @@protoc_insertion_point(class_scope:bestan.common.config.excel_cell_data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr bytes_value_;
  int data_type_;
  ::google::protobuf::int32 int32_value_;
  ::google::protobuf::int64 int64_value_;
  double double_value_;
  float float_value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_template_5fbase_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class excel_line_data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bestan.common.config.excel_line_data) */ {
 public:
  excel_line_data();
  virtual ~excel_line_data();

  excel_line_data(const excel_line_data& from);

  inline excel_line_data& operator=(const excel_line_data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  excel_line_data(excel_line_data&& from) noexcept
    : excel_line_data() {
    *this = ::std::move(from);
  }

  inline excel_line_data& operator=(excel_line_data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const excel_line_data& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const excel_line_data* internal_default_instance() {
    return reinterpret_cast<const excel_line_data*>(
               &_excel_line_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(excel_line_data* other);
  friend void swap(excel_line_data& a, excel_line_data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline excel_line_data* New() const final {
    return CreateMaybeMessage<excel_line_data>(NULL);
  }

  excel_line_data* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<excel_line_data>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const excel_line_data& from);
  void MergeFrom(const excel_line_data& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(excel_line_data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .bestan.common.config.excel_cell_data cell_data = 1;
  int cell_data_size() const;
  void clear_cell_data();
  static const int kCellDataFieldNumber = 1;
  ::bestan::common::config::excel_cell_data* mutable_cell_data(int index);
  ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_cell_data >*
      mutable_cell_data();
  const ::bestan::common::config::excel_cell_data& cell_data(int index) const;
  ::bestan::common::config::excel_cell_data* add_cell_data();
  const ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_cell_data >&
      cell_data() const;

  // @@protoc_insertion_point(class_scope:bestan.common.config.excel_line_data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_cell_data > cell_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_template_5fbase_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class excel_table_TableEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<excel_table_TableEntry_DoNotUse, 
    ::google::protobuf::int32, ::bestan::common::config::excel_line_data,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<excel_table_TableEntry_DoNotUse, 
    ::google::protobuf::int32, ::bestan::common::config::excel_line_data,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  excel_table_TableEntry_DoNotUse();
  excel_table_TableEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const excel_table_TableEntry_DoNotUse& other);
  static const excel_table_TableEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const excel_table_TableEntry_DoNotUse*>(&_excel_table_TableEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class excel_table : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bestan.common.config.excel_table) */ {
 public:
  excel_table();
  virtual ~excel_table();

  excel_table(const excel_table& from);

  inline excel_table& operator=(const excel_table& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  excel_table(excel_table&& from) noexcept
    : excel_table() {
    *this = ::std::move(from);
  }

  inline excel_table& operator=(excel_table&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const excel_table& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const excel_table* internal_default_instance() {
    return reinterpret_cast<const excel_table*>(
               &_excel_table_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(excel_table* other);
  friend void swap(excel_table& a, excel_table& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline excel_table* New() const final {
    return CreateMaybeMessage<excel_table>(NULL);
  }

  excel_table* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<excel_table>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const excel_table& from);
  void MergeFrom(const excel_table& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(excel_table* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .bestan.common.config.excel_line_data> table = 3;
  int table_size() const;
  void clear_table();
  static const int kTableFieldNumber = 3;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::bestan::common::config::excel_line_data >&
      table() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::bestan::common::config::excel_line_data >*
      mutable_table();

  // bytes proto_msg_name = 1;
  void clear_proto_msg_name();
  static const int kProtoMsgNameFieldNumber = 1;
  const ::std::string& proto_msg_name() const;
  void set_proto_msg_name(const ::std::string& value);
  #if LANG_CXX11
  void set_proto_msg_name(::std::string&& value);
  #endif
  void set_proto_msg_name(const char* value);
  void set_proto_msg_name(const void* value, size_t size);
  ::std::string* mutable_proto_msg_name();
  ::std::string* release_proto_msg_name();
  void set_allocated_proto_msg_name(::std::string* proto_msg_name);

  // .bestan.common.config.excel_path_full path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  private:
  const ::bestan::common::config::excel_path_full& _internal_path() const;
  public:
  const ::bestan::common::config::excel_path_full& path() const;
  ::bestan::common::config::excel_path_full* release_path();
  ::bestan::common::config::excel_path_full* mutable_path();
  void set_allocated_path(::bestan::common::config::excel_path_full* path);

  // @@protoc_insertion_point(class_scope:bestan.common.config.excel_table)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      excel_table_TableEntry_DoNotUse,
      ::google::protobuf::int32, ::bestan::common::config::excel_line_data,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > table_;
  ::google::protobuf::internal::ArenaStringPtr proto_msg_name_;
  ::bestan::common::config::excel_path_full* path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_template_5fbase_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class excel_proto_AllProtoEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<excel_proto_AllProtoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<excel_proto_AllProtoEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
    0 > SuperType;
  excel_proto_AllProtoEntry_DoNotUse();
  excel_proto_AllProtoEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const excel_proto_AllProtoEntry_DoNotUse& other);
  static const excel_proto_AllProtoEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const excel_proto_AllProtoEntry_DoNotUse*>(&_excel_proto_AllProtoEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class excel_proto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bestan.common.config.excel_proto) */ {
 public:
  excel_proto();
  virtual ~excel_proto();

  excel_proto(const excel_proto& from);

  inline excel_proto& operator=(const excel_proto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  excel_proto(excel_proto&& from) noexcept
    : excel_proto() {
    *this = ::std::move(from);
  }

  inline excel_proto& operator=(excel_proto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const excel_proto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const excel_proto* internal_default_instance() {
    return reinterpret_cast<const excel_proto*>(
               &_excel_proto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(excel_proto* other);
  friend void swap(excel_proto& a, excel_proto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline excel_proto* New() const final {
    return CreateMaybeMessage<excel_proto>(NULL);
  }

  excel_proto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<excel_proto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const excel_proto& from);
  void MergeFrom(const excel_proto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(excel_proto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bytes> all_proto = 1;
  int all_proto_size() const;
  void clear_all_proto();
  static const int kAllProtoFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      all_proto() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_all_proto();

  // @@protoc_insertion_point(class_scope:bestan.common.config.excel_proto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      excel_proto_AllProtoEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BYTES,
      0 > all_proto_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_template_5fbase_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class test_python_skill_data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bestan.common.config.test_python.skill_data) */ {
 public:
  test_python_skill_data();
  virtual ~test_python_skill_data();

  test_python_skill_data(const test_python_skill_data& from);

  inline test_python_skill_data& operator=(const test_python_skill_data& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  test_python_skill_data(test_python_skill_data&& from) noexcept
    : test_python_skill_data() {
    *this = ::std::move(from);
  }

  inline test_python_skill_data& operator=(test_python_skill_data&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const test_python_skill_data& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const test_python_skill_data* internal_default_instance() {
    return reinterpret_cast<const test_python_skill_data*>(
               &_test_python_skill_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(test_python_skill_data* other);
  friend void swap(test_python_skill_data& a, test_python_skill_data& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline test_python_skill_data* New() const final {
    return CreateMaybeMessage<test_python_skill_data>(NULL);
  }

  test_python_skill_data* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<test_python_skill_data>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const test_python_skill_data& from);
  void MergeFrom(const test_python_skill_data& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(test_python_skill_data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 rate = 2;
  void clear_rate();
  static const int kRateFieldNumber = 2;
  ::google::protobuf::int32 rate() const;
  void set_rate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bestan.common.config.test_python.skill_data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 rate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_template_5fbase_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class test_python : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bestan.common.config.test_python) */ {
 public:
  test_python();
  virtual ~test_python();

  test_python(const test_python& from);

  inline test_python& operator=(const test_python& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  test_python(test_python&& from) noexcept
    : test_python() {
    *this = ::std::move(from);
  }

  inline test_python& operator=(test_python&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const test_python& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const test_python* internal_default_instance() {
    return reinterpret_cast<const test_python*>(
               &_test_python_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(test_python* other);
  friend void swap(test_python& a, test_python& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline test_python* New() const final {
    return CreateMaybeMessage<test_python>(NULL);
  }

  test_python* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<test_python>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const test_python& from);
  void MergeFrom(const test_python& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(test_python* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef test_python_skill_data skill_data;

  // accessors -------------------------------------------------------

  // .bestan.common.config.test_python.skill_data skill = 3;
  bool has_skill() const;
  void clear_skill();
  static const int kSkillFieldNumber = 3;
  private:
  const ::bestan::common::config::test_python_skill_data& _internal_skill() const;
  public:
  const ::bestan::common::config::test_python_skill_data& skill() const;
  ::bestan::common::config::test_python_skill_data* release_skill();
  ::bestan::common::config::test_python_skill_data* mutable_skill();
  void set_allocated_skill(::bestan::common::config::test_python_skill_data* skill);

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // int32 count = 2;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::int32 count() const;
  void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:bestan.common.config.test_python)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::bestan::common::config::test_python_skill_data* skill_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int32 count_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_template_5fbase_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class test_python_all_ConfigsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<test_python_all_ConfigsEntry_DoNotUse, 
    ::google::protobuf::int32, ::bestan::common::config::test_python,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<test_python_all_ConfigsEntry_DoNotUse, 
    ::google::protobuf::int32, ::bestan::common::config::test_python,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  test_python_all_ConfigsEntry_DoNotUse();
  test_python_all_ConfigsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const test_python_all_ConfigsEntry_DoNotUse& other);
  static const test_python_all_ConfigsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const test_python_all_ConfigsEntry_DoNotUse*>(&_test_python_all_ConfigsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class test_python_all : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:bestan.common.config.test_python_all) */ {
 public:
  test_python_all();
  virtual ~test_python_all();

  test_python_all(const test_python_all& from);

  inline test_python_all& operator=(const test_python_all& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  test_python_all(test_python_all&& from) noexcept
    : test_python_all() {
    *this = ::std::move(from);
  }

  inline test_python_all& operator=(test_python_all&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const test_python_all& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const test_python_all* internal_default_instance() {
    return reinterpret_cast<const test_python_all*>(
               &_test_python_all_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(test_python_all* other);
  friend void swap(test_python_all& a, test_python_all& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline test_python_all* New() const final {
    return CreateMaybeMessage<test_python_all>(NULL);
  }

  test_python_all* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<test_python_all>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const test_python_all& from);
  void MergeFrom(const test_python_all& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(test_python_all* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<int32, .bestan.common.config.test_python> configs = 1;
  int configs_size() const;
  void clear_configs();
  static const int kConfigsFieldNumber = 1;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::bestan::common::config::test_python >&
      configs() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::bestan::common::config::test_python >*
      mutable_configs();

  // @@protoc_insertion_point(class_scope:bestan.common.config.test_python_all)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      test_python_all_ConfigsEntry_DoNotUse,
      ::google::protobuf::int32, ::bestan::common::config::test_python,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > configs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_template_5fbase_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// excel_section

// bytes section = 1;
inline void excel_section::clear_section() {
  section_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& excel_section::section() const {
  // @@protoc_insertion_point(field_get:bestan.common.config.excel_section.section)
  return section_.GetNoArena();
}
inline void excel_section::set_section(const ::std::string& value) {
  
  section_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bestan.common.config.excel_section.section)
}
#if LANG_CXX11
inline void excel_section::set_section(::std::string&& value) {
  
  section_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bestan.common.config.excel_section.section)
}
#endif
inline void excel_section::set_section(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  section_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bestan.common.config.excel_section.section)
}
inline void excel_section::set_section(const void* value, size_t size) {
  
  section_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bestan.common.config.excel_section.section)
}
inline ::std::string* excel_section::mutable_section() {
  
  // @@protoc_insertion_point(field_mutable:bestan.common.config.excel_section.section)
  return section_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* excel_section::release_section() {
  // @@protoc_insertion_point(field_release:bestan.common.config.excel_section.section)
  
  return section_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void excel_section::set_allocated_section(::std::string* section) {
  if (section != NULL) {
    
  } else {
    
  }
  section_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), section);
  // @@protoc_insertion_point(field_set_allocated:bestan.common.config.excel_section.section)
}

// int32 index = 2;
inline void excel_section::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 excel_section::index() const {
  // @@protoc_insertion_point(field_get:bestan.common.config.excel_section.index)
  return index_;
}
inline void excel_section::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:bestan.common.config.excel_section.index)
}

// .bestan.common.config.excel_section.DATA_TYPE data_type = 3;
inline void excel_section::clear_data_type() {
  data_type_ = 0;
}
inline ::bestan::common::config::excel_section_DATA_TYPE excel_section::data_type() const {
  // @@protoc_insertion_point(field_get:bestan.common.config.excel_section.data_type)
  return static_cast< ::bestan::common::config::excel_section_DATA_TYPE >(data_type_);
}
inline void excel_section::set_data_type(::bestan::common::config::excel_section_DATA_TYPE value) {
  
  data_type_ = value;
  // @@protoc_insertion_point(field_set:bestan.common.config.excel_section.data_type)
}

// -------------------------------------------------------------------

// excel_path_cell

// repeated .bestan.common.config.excel_section cell_path = 1;
inline int excel_path_cell::cell_path_size() const {
  return cell_path_.size();
}
inline void excel_path_cell::clear_cell_path() {
  cell_path_.Clear();
}
inline ::bestan::common::config::excel_section* excel_path_cell::mutable_cell_path(int index) {
  // @@protoc_insertion_point(field_mutable:bestan.common.config.excel_path_cell.cell_path)
  return cell_path_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_section >*
excel_path_cell::mutable_cell_path() {
  // @@protoc_insertion_point(field_mutable_list:bestan.common.config.excel_path_cell.cell_path)
  return &cell_path_;
}
inline const ::bestan::common::config::excel_section& excel_path_cell::cell_path(int index) const {
  // @@protoc_insertion_point(field_get:bestan.common.config.excel_path_cell.cell_path)
  return cell_path_.Get(index);
}
inline ::bestan::common::config::excel_section* excel_path_cell::add_cell_path() {
  // @@protoc_insertion_point(field_add:bestan.common.config.excel_path_cell.cell_path)
  return cell_path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_section >&
excel_path_cell::cell_path() const {
  // @@protoc_insertion_point(field_list:bestan.common.config.excel_path_cell.cell_path)
  return cell_path_;
}

// -------------------------------------------------------------------

// excel_path_full

// repeated .bestan.common.config.excel_path_cell paths = 1;
inline int excel_path_full::paths_size() const {
  return paths_.size();
}
inline void excel_path_full::clear_paths() {
  paths_.Clear();
}
inline ::bestan::common::config::excel_path_cell* excel_path_full::mutable_paths(int index) {
  // @@protoc_insertion_point(field_mutable:bestan.common.config.excel_path_full.paths)
  return paths_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_path_cell >*
excel_path_full::mutable_paths() {
  // @@protoc_insertion_point(field_mutable_list:bestan.common.config.excel_path_full.paths)
  return &paths_;
}
inline const ::bestan::common::config::excel_path_cell& excel_path_full::paths(int index) const {
  // @@protoc_insertion_point(field_get:bestan.common.config.excel_path_full.paths)
  return paths_.Get(index);
}
inline ::bestan::common::config::excel_path_cell* excel_path_full::add_paths() {
  // @@protoc_insertion_point(field_add:bestan.common.config.excel_path_full.paths)
  return paths_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_path_cell >&
excel_path_full::paths() const {
  // @@protoc_insertion_point(field_list:bestan.common.config.excel_path_full.paths)
  return paths_;
}

// -------------------------------------------------------------------

// excel_cell_data

// .bestan.common.config.excel_cell_data.DATA_TYPE data_type = 1;
inline void excel_cell_data::clear_data_type() {
  data_type_ = 0;
}
inline ::bestan::common::config::excel_cell_data_DATA_TYPE excel_cell_data::data_type() const {
  // @@protoc_insertion_point(field_get:bestan.common.config.excel_cell_data.data_type)
  return static_cast< ::bestan::common::config::excel_cell_data_DATA_TYPE >(data_type_);
}
inline void excel_cell_data::set_data_type(::bestan::common::config::excel_cell_data_DATA_TYPE value) {
  
  data_type_ = value;
  // @@protoc_insertion_point(field_set:bestan.common.config.excel_cell_data.data_type)
}

// int32 int32_value = 2;
inline void excel_cell_data::clear_int32_value() {
  int32_value_ = 0;
}
inline ::google::protobuf::int32 excel_cell_data::int32_value() const {
  // @@protoc_insertion_point(field_get:bestan.common.config.excel_cell_data.int32_value)
  return int32_value_;
}
inline void excel_cell_data::set_int32_value(::google::protobuf::int32 value) {
  
  int32_value_ = value;
  // @@protoc_insertion_point(field_set:bestan.common.config.excel_cell_data.int32_value)
}

// int64 int64_value = 3;
inline void excel_cell_data::clear_int64_value() {
  int64_value_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 excel_cell_data::int64_value() const {
  // @@protoc_insertion_point(field_get:bestan.common.config.excel_cell_data.int64_value)
  return int64_value_;
}
inline void excel_cell_data::set_int64_value(::google::protobuf::int64 value) {
  
  int64_value_ = value;
  // @@protoc_insertion_point(field_set:bestan.common.config.excel_cell_data.int64_value)
}

// bytes bytes_value = 4;
inline void excel_cell_data::clear_bytes_value() {
  bytes_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& excel_cell_data::bytes_value() const {
  // @@protoc_insertion_point(field_get:bestan.common.config.excel_cell_data.bytes_value)
  return bytes_value_.GetNoArena();
}
inline void excel_cell_data::set_bytes_value(const ::std::string& value) {
  
  bytes_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bestan.common.config.excel_cell_data.bytes_value)
}
#if LANG_CXX11
inline void excel_cell_data::set_bytes_value(::std::string&& value) {
  
  bytes_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bestan.common.config.excel_cell_data.bytes_value)
}
#endif
inline void excel_cell_data::set_bytes_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  bytes_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bestan.common.config.excel_cell_data.bytes_value)
}
inline void excel_cell_data::set_bytes_value(const void* value, size_t size) {
  
  bytes_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bestan.common.config.excel_cell_data.bytes_value)
}
inline ::std::string* excel_cell_data::mutable_bytes_value() {
  
  // @@protoc_insertion_point(field_mutable:bestan.common.config.excel_cell_data.bytes_value)
  return bytes_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* excel_cell_data::release_bytes_value() {
  // @@protoc_insertion_point(field_release:bestan.common.config.excel_cell_data.bytes_value)
  
  return bytes_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void excel_cell_data::set_allocated_bytes_value(::std::string* bytes_value) {
  if (bytes_value != NULL) {
    
  } else {
    
  }
  bytes_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bytes_value);
  // @@protoc_insertion_point(field_set_allocated:bestan.common.config.excel_cell_data.bytes_value)
}

// float float_value = 5;
inline void excel_cell_data::clear_float_value() {
  float_value_ = 0;
}
inline float excel_cell_data::float_value() const {
  // @@protoc_insertion_point(field_get:bestan.common.config.excel_cell_data.float_value)
  return float_value_;
}
inline void excel_cell_data::set_float_value(float value) {
  
  float_value_ = value;
  // @@protoc_insertion_point(field_set:bestan.common.config.excel_cell_data.float_value)
}

// double double_value = 6;
inline void excel_cell_data::clear_double_value() {
  double_value_ = 0;
}
inline double excel_cell_data::double_value() const {
  // @@protoc_insertion_point(field_get:bestan.common.config.excel_cell_data.double_value)
  return double_value_;
}
inline void excel_cell_data::set_double_value(double value) {
  
  double_value_ = value;
  // @@protoc_insertion_point(field_set:bestan.common.config.excel_cell_data.double_value)
}

// -------------------------------------------------------------------

// excel_line_data

// repeated .bestan.common.config.excel_cell_data cell_data = 1;
inline int excel_line_data::cell_data_size() const {
  return cell_data_.size();
}
inline void excel_line_data::clear_cell_data() {
  cell_data_.Clear();
}
inline ::bestan::common::config::excel_cell_data* excel_line_data::mutable_cell_data(int index) {
  // @@protoc_insertion_point(field_mutable:bestan.common.config.excel_line_data.cell_data)
  return cell_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_cell_data >*
excel_line_data::mutable_cell_data() {
  // @@protoc_insertion_point(field_mutable_list:bestan.common.config.excel_line_data.cell_data)
  return &cell_data_;
}
inline const ::bestan::common::config::excel_cell_data& excel_line_data::cell_data(int index) const {
  // @@protoc_insertion_point(field_get:bestan.common.config.excel_line_data.cell_data)
  return cell_data_.Get(index);
}
inline ::bestan::common::config::excel_cell_data* excel_line_data::add_cell_data() {
  // @@protoc_insertion_point(field_add:bestan.common.config.excel_line_data.cell_data)
  return cell_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::bestan::common::config::excel_cell_data >&
excel_line_data::cell_data() const {
  // @@protoc_insertion_point(field_list:bestan.common.config.excel_line_data.cell_data)
  return cell_data_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// excel_table

// bytes proto_msg_name = 1;
inline void excel_table::clear_proto_msg_name() {
  proto_msg_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& excel_table::proto_msg_name() const {
  // @@protoc_insertion_point(field_get:bestan.common.config.excel_table.proto_msg_name)
  return proto_msg_name_.GetNoArena();
}
inline void excel_table::set_proto_msg_name(const ::std::string& value) {
  
  proto_msg_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:bestan.common.config.excel_table.proto_msg_name)
}
#if LANG_CXX11
inline void excel_table::set_proto_msg_name(::std::string&& value) {
  
  proto_msg_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:bestan.common.config.excel_table.proto_msg_name)
}
#endif
inline void excel_table::set_proto_msg_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  proto_msg_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:bestan.common.config.excel_table.proto_msg_name)
}
inline void excel_table::set_proto_msg_name(const void* value, size_t size) {
  
  proto_msg_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:bestan.common.config.excel_table.proto_msg_name)
}
inline ::std::string* excel_table::mutable_proto_msg_name() {
  
  // @@protoc_insertion_point(field_mutable:bestan.common.config.excel_table.proto_msg_name)
  return proto_msg_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* excel_table::release_proto_msg_name() {
  // @@protoc_insertion_point(field_release:bestan.common.config.excel_table.proto_msg_name)
  
  return proto_msg_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void excel_table::set_allocated_proto_msg_name(::std::string* proto_msg_name) {
  if (proto_msg_name != NULL) {
    
  } else {
    
  }
  proto_msg_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proto_msg_name);
  // @@protoc_insertion_point(field_set_allocated:bestan.common.config.excel_table.proto_msg_name)
}

// .bestan.common.config.excel_path_full path = 2;
inline bool excel_table::has_path() const {
  return this != internal_default_instance() && path_ != NULL;
}
inline void excel_table::clear_path() {
  if (GetArenaNoVirtual() == NULL && path_ != NULL) {
    delete path_;
  }
  path_ = NULL;
}
inline const ::bestan::common::config::excel_path_full& excel_table::_internal_path() const {
  return *path_;
}
inline const ::bestan::common::config::excel_path_full& excel_table::path() const {
  const ::bestan::common::config::excel_path_full* p = path_;
  // @@protoc_insertion_point(field_get:bestan.common.config.excel_table.path)
  return p != NULL ? *p : *reinterpret_cast<const ::bestan::common::config::excel_path_full*>(
      &::bestan::common::config::_excel_path_full_default_instance_);
}
inline ::bestan::common::config::excel_path_full* excel_table::release_path() {
  // @@protoc_insertion_point(field_release:bestan.common.config.excel_table.path)
  
  ::bestan::common::config::excel_path_full* temp = path_;
  path_ = NULL;
  return temp;
}
inline ::bestan::common::config::excel_path_full* excel_table::mutable_path() {
  
  if (path_ == NULL) {
    auto* p = CreateMaybeMessage<::bestan::common::config::excel_path_full>(GetArenaNoVirtual());
    path_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bestan.common.config.excel_table.path)
  return path_;
}
inline void excel_table::set_allocated_path(::bestan::common::config::excel_path_full* path) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete path_;
  }
  if (path) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      path = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, path, submessage_arena);
    }
    
  } else {
    
  }
  path_ = path;
  // @@protoc_insertion_point(field_set_allocated:bestan.common.config.excel_table.path)
}

// map<int32, .bestan.common.config.excel_line_data> table = 3;
inline int excel_table::table_size() const {
  return table_.size();
}
inline void excel_table::clear_table() {
  table_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::bestan::common::config::excel_line_data >&
excel_table::table() const {
  // @@protoc_insertion_point(field_map:bestan.common.config.excel_table.table)
  return table_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::bestan::common::config::excel_line_data >*
excel_table::mutable_table() {
  // @@protoc_insertion_point(field_mutable_map:bestan.common.config.excel_table.table)
  return table_.MutableMap();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// excel_proto

// map<string, bytes> all_proto = 1;
inline int excel_proto::all_proto_size() const {
  return all_proto_.size();
}
inline void excel_proto::clear_all_proto() {
  all_proto_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
excel_proto::all_proto() const {
  // @@protoc_insertion_point(field_map:bestan.common.config.excel_proto.all_proto)
  return all_proto_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
excel_proto::mutable_all_proto() {
  // @@protoc_insertion_point(field_mutable_map:bestan.common.config.excel_proto.all_proto)
  return all_proto_.MutableMap();
}

// -------------------------------------------------------------------

// test_python_skill_data

// int32 id = 1;
inline void test_python_skill_data::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 test_python_skill_data::id() const {
  // @@protoc_insertion_point(field_get:bestan.common.config.test_python.skill_data.id)
  return id_;
}
inline void test_python_skill_data::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:bestan.common.config.test_python.skill_data.id)
}

// int32 rate = 2;
inline void test_python_skill_data::clear_rate() {
  rate_ = 0;
}
inline ::google::protobuf::int32 test_python_skill_data::rate() const {
  // @@protoc_insertion_point(field_get:bestan.common.config.test_python.skill_data.rate)
  return rate_;
}
inline void test_python_skill_data::set_rate(::google::protobuf::int32 value) {
  
  rate_ = value;
  // @@protoc_insertion_point(field_set:bestan.common.config.test_python.skill_data.rate)
}

// -------------------------------------------------------------------

// test_python

// int64 id = 1;
inline void test_python::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 test_python::id() const {
  // @@protoc_insertion_point(field_get:bestan.common.config.test_python.id)
  return id_;
}
inline void test_python::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:bestan.common.config.test_python.id)
}

// int32 count = 2;
inline void test_python::clear_count() {
  count_ = 0;
}
inline ::google::protobuf::int32 test_python::count() const {
  // @@protoc_insertion_point(field_get:bestan.common.config.test_python.count)
  return count_;
}
inline void test_python::set_count(::google::protobuf::int32 value) {
  
  count_ = value;
  // @@protoc_insertion_point(field_set:bestan.common.config.test_python.count)
}

// .bestan.common.config.test_python.skill_data skill = 3;
inline bool test_python::has_skill() const {
  return this != internal_default_instance() && skill_ != NULL;
}
inline void test_python::clear_skill() {
  if (GetArenaNoVirtual() == NULL && skill_ != NULL) {
    delete skill_;
  }
  skill_ = NULL;
}
inline const ::bestan::common::config::test_python_skill_data& test_python::_internal_skill() const {
  return *skill_;
}
inline const ::bestan::common::config::test_python_skill_data& test_python::skill() const {
  const ::bestan::common::config::test_python_skill_data* p = skill_;
  // @@protoc_insertion_point(field_get:bestan.common.config.test_python.skill)
  return p != NULL ? *p : *reinterpret_cast<const ::bestan::common::config::test_python_skill_data*>(
      &::bestan::common::config::_test_python_skill_data_default_instance_);
}
inline ::bestan::common::config::test_python_skill_data* test_python::release_skill() {
  // @@protoc_insertion_point(field_release:bestan.common.config.test_python.skill)
  
  ::bestan::common::config::test_python_skill_data* temp = skill_;
  skill_ = NULL;
  return temp;
}
inline ::bestan::common::config::test_python_skill_data* test_python::mutable_skill() {
  
  if (skill_ == NULL) {
    auto* p = CreateMaybeMessage<::bestan::common::config::test_python_skill_data>(GetArenaNoVirtual());
    skill_ = p;
  }
  // @@protoc_insertion_point(field_mutable:bestan.common.config.test_python.skill)
  return skill_;
}
inline void test_python::set_allocated_skill(::bestan::common::config::test_python_skill_data* skill) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete skill_;
  }
  if (skill) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      skill = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, skill, submessage_arena);
    }
    
  } else {
    
  }
  skill_ = skill;
  // @@protoc_insertion_point(field_set_allocated:bestan.common.config.test_python.skill)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// test_python_all

// map<int32, .bestan.common.config.test_python> configs = 1;
inline int test_python_all::configs_size() const {
  return configs_.size();
}
inline void test_python_all::clear_configs() {
  configs_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::bestan::common::config::test_python >&
test_python_all::configs() const {
  // @@protoc_insertion_point(field_map:bestan.common.config.test_python_all.configs)
  return configs_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::bestan::common::config::test_python >*
test_python_all::mutable_configs() {
  // @@protoc_insertion_point(field_mutable_map:bestan.common.config.test_python_all.configs)
  return configs_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace config
}  // namespace common
}  // namespace bestan

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::bestan::common::config::excel_section_DATA_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bestan::common::config::excel_section_DATA_TYPE>() {
  return ::bestan::common::config::excel_section_DATA_TYPE_descriptor();
}
template <> struct is_proto_enum< ::bestan::common::config::excel_cell_data_DATA_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::bestan::common::config::excel_cell_data_DATA_TYPE>() {
  return ::bestan::common::config::excel_cell_data_DATA_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_template_5fbase_2eproto
